{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CyNetDiff","text":"<ul> <li>Documentation: https://eliotwrobson.github.io/CyNetDiff/</li> <li>Examples: https://eliotwrobson.github.io/CyNetDiff/examples/preliminaries/</li> <li>Benchmarks: </li> </ul> <p>Network diffusion processes aim to model the spread of trends through social networks, represented using graphs. Experimental work with these models usually involves simulating these processes many times over large graphs, which can be computationally very expensive. To address this, CyNetDiff is a Cython module implementing the independent cascade and linear threshold models. Development has been focused on performance, while still giving an intuitive, high-level interface to assist in research tasks. To learn more about these specific models, read this book chapter or the preliminaries page in the documentation.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p><pre><code>pip install cynetdiff\n</code></pre> Note: The installation includes a build step that requires having a C++ complier installed.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>We can run models over graphs we define, using pre-defined weighting schemes. Here is a simple example: <pre><code>import random\nimport networkx as nx\nfrom cynetdiff.utils import networkx_to_ic_model\n\n# Randomly generate the graph\nn = 1_000\np = 0.05\ngraph = nx.fast_gnp_random_graph(n, p)\n\n# Randomly choose seed nodes\nk = 10\nnodes = list(graph.nodes)\nseeds = random.sample(nodes, k)\n\n# Set the activation probability uniformly and set seeds\nmodel, _ = networkx_to_ic_model(graph, activation_prob=0.2)\nmodel.set_seeds(seeds)\n\n# Run a single diffusion process until completion\nmodel.advance_until_completion()\n\n# Get the number of nodes activated\nmodel.get_num_activated_nodes()\n</code></pre></p> <p>The output from the last line is the number of nodes activated in a single simulation of the model. To get the average number of activated nodes across <code>n_sim = 1_000</code> simulations, we can replace the last line in the above with the following:</p> <pre><code>n_sim = 1_000\ntotal = 0.0\n\nfor _ in range(n_sim):\n    # Resetting the model doesn't change the initial seed set used.\n    model.reset_model()\n    model.advance_until_completion()\n    total += model.get_num_activated_nodes()\n\navg = total / n_sim\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":"<p>See the documentation.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this code in your research, please use the following citation: <pre><code>@article{DBLP:journals/pvldb/RobsonRU24,\n  author       = {Eilot W. Robson and\n                  Dhemath Reddy and\n                  Abhishek Kumar Umrawal},\n  title        = {CyNetDiff: {A} Python Library for Accelerated Implementation of Network\n                  Diffusion Models},\n  journal      = {Proc. {VLDB} Endow.},\n  volume       = {17},\n  number       = {12},\n  pages        = {4409--4412},\n  year         = {2024},\n  url          = {https://www.vldb.org/pvldb/vol17/p4409-umrawal.pdf},\n  timestamp    = {Thu, 19 Sep 2024 13:09:38 +0200},\n  biburl       = {https://dblp.org/rec/journals/pvldb/RobsonRU24.bib},\n  bibsource    = {dblp computer science bibliography, https://dblp.org}\n}\n</code></pre></p>"},{"location":"#project-status","title":"Project Status","text":"<p>This project is still considered in a beta stage of development. As such, the API could still change to facilitate easier community adoption.</p> <p>All feedback is greatly appreciated!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are always welcome! Take a look at the contributing guide.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at eliot.robson24@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to CyNetDiff","text":""},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>When interacting with other users and maintainers, please be sure to abide by the Code of Conduct.</p>"},{"location":"CONTRIBUTING/#submitting-an-issue","title":"Submitting an issue","text":""},{"location":"CONTRIBUTING/#bug-reports","title":"Bug reports","text":"<p>If you are submitting a bug report, please answer the following questions:</p> <ol> <li>What version of CyNetDiff were you using?</li> <li>What were you doing?</li> <li>What did you expect to happen?</li> <li>What happened instead?</li> </ol> <p>Please provide any code to reproduce the issue, if possible.</p>"},{"location":"CONTRIBUTING/#new-features","title":"New features","text":"<p>If you are requesting a new feature or change or behavior, please describe what you are looking for, and what implementation would make this feature beneficial for your use case.</p>"},{"location":"CONTRIBUTING/#modifying-the-codebase","title":"Modifying the codebase","text":"<p>CyNetDiff is an open-source project under the MIT License, so you are welcome and encouraged to modify the codebase with new fixes and enhancements. Please observe the following guidelines when submitting pull requests for new fixes or features:</p> <ol> <li> <p>All new code must be formatted with ruff. The .vscode directory in this repository is configured to autoformat with ruff on save if you are using VSCode.</p> </li> <li> <p>Whether you are introducing a bug fix or a new feature, you must add tests to verify that your code additions function correctly and break nothing else.</p> </li> <li> <p>Make sure that all new code includes updated docstrings in the NumPy style.</p> </li> <li> <p>If you are adding a new feature or changing behavior, please update the documentation appropriately with the relevant information. To run the documentation site locally, install the documentation dependencies with:</p> </li> </ol> <pre><code>poetry install --with docs\n</code></pre> <p>Then, start the local server with the following command:</p> <pre><code>poetry run mkdocs serve\n</code></pre>"},{"location":"CONTRIBUTING/#using-poetry","title":"Using Poetry","text":"<p>This project is developed using poetry. It is strongly recommended for local development.</p>"},{"location":"CONTRIBUTING/#installing-project-dependencies","title":"Installing project dependencies","text":"<p>To install the local version of the library with development dependencies, run the following:</p> <pre><code>poetry install --with dev\n</code></pre>"},{"location":"CONTRIBUTING/#cython-generation","title":"Cython Generation","text":"<p>The Cython code for this project is generated and then committed to the repository. This code generation is not enabled by default. To enable this, add <code>\"cython\"</code> to the build dependencies in <code>pyproject.toml</code>. Make sure not to commit this change, as it just enables regeneration of the C++ files from Cython code.</p>"},{"location":"CONTRIBUTING/#running-unit-tests","title":"Running unit tests","text":"<p>The unit tests use pytest.</p> <pre><code>poetry run pytest\n</code></pre>"},{"location":"people/","title":"People","text":""},{"location":"people/#maintainers","title":"Maintainers","text":"<ul> <li>eliotwrobson</li> <li>abhishekumrawal</li> </ul>"},{"location":"people/#contributors","title":"Contributors","text":"<ul> <li>Dhemath Reddy</li> </ul>"},{"location":"api/","title":"API","text":"<p>This is the API documentation generated by the class and method docstrings for the <code>CyNetDiff</code> package.</p>"},{"location":"api/models/","title":"Models","text":""},{"location":"api/models/#cynetdiff.models","title":"<code>cynetdiff.models</code>","text":""},{"location":"api/models/#cynetdiff.models.DiffusionModel","title":"<code>DiffusionModel</code>","text":"<p>Base class for Diffusion Models. This class provides an interface for advancing, resetting, and retrieving newly activated nodes. Nodes for the graph of the diffusion process have labels in [0, n-1] and the graph is represented in compressed sparse row format.</p>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.advance_model","title":"<code>advance_model()</code>","text":"<p>Advances the diffusion model by one step. Since these diffusion models are progressive, the number of activated nodes cannot decrease.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; old_num_active = model.get_num_activated_nodes()\n&gt;&gt;&gt; model.advance_model()\n&gt;&gt;&gt; model.get_num_activated_nodes() &gt;= old_num_active\nTrue\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.advance_until_completion","title":"<code>advance_until_completion()</code>","text":"<p>Continuously advances the model until the diffusion process is complete.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.advance_until_completion()\n&gt;&gt;&gt; activated_nodes = model.get_num_activated_nodes()\n&gt;&gt;&gt; model.advance_model()\n&gt;&gt;&gt; activated_nodes == model.get_num_activated_nodes()\nTrue\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.compute_payoffs","title":"<code>compute_payoffs()</code>","text":"<p>Computes the payoffs of each active node. Payoffs are defaulted to 1.0 if not set.</p> <p>Returns:</p> Type Description <code>float</code> <p>Sum of payoffs for all activated nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.set_seeds([0, 1, 2])\n&gt;&gt;&gt; model.compute_payoffs()\n3.0\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.get_activated_nodes","title":"<code>get_activated_nodes()</code>","text":"<p>Yields all activated nodes.</p> <p>Yields:</p> Type Description <code>int</code> <p>All of the currently activated nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.set_seeds([0, 1, 2])\n&gt;&gt;&gt; for node in model.get_activated_nodes()\n...    print(node)\n0\n1\n2\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.get_newly_activated_nodes","title":"<code>get_newly_activated_nodes()</code>","text":"<p>A generator yielding the nodes that were newly activated in the last iteration of the model. If the model has not yet been run, this is just the current seed nodes.</p> <p>Yields:</p> Type Description <code>int</code> <p>The label of a node that was newly activated.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.set_seeds([0, 1, 2])\n&gt;&gt;&gt; set(model.get_newly_activated_nodes())\n{0, 1, 2}\n&gt;&gt;&gt; model.advance_until_completion()\n&gt;&gt;&gt; len(set(model.get_newly_activated_nodes()))\n0\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.get_num_activated_nodes","title":"<code>get_num_activated_nodes()</code>","text":"<p>Returns the total number of activated nodes in the model.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total number of activated nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.set_seeds([0, 1, 2])\n&gt;&gt;&gt; model.get_num_activated_nodes()\n3\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.reset_model","title":"<code>reset_model()</code>","text":"<p>Resets the model to the original set of seed nodes. This is useful if running many simulations over the same original seed set. If randomized activation is enabled, resetting the model will perform the randomized activation step.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.set_seeds([0, 1, 2])\n&gt;&gt;&gt; model.advance_until_completion()\n&gt;&gt;&gt; model.get_num_activated_nodes()\n10\n&gt;&gt;&gt; model.reset_model()\n&gt;&gt;&gt; model.get_num_activated_nodes()\n3\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.set_rng","title":"<code>set_rng(rng=None)</code>","text":"<p>Sets the random number generator for the model. If not set, creates a new generator by default.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>SeedLike | RNGLike | None</code> <p>Random number generator to use for the model.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rng_seed = 42\n&gt;&gt;&gt; model.set_rng(rng_seed)\n&gt;&gt;&gt; model.advance_until_completion()\n&gt;&gt;&gt; old_num = model.get_num_activated_nodes()\n&gt;&gt;&gt; model.set_rng(rng_seed)\n&gt;&gt;&gt; model.advance_until_completion()\n&gt;&gt;&gt; old_num == model.get_num_activated_nodes()\nTrue\n</code></pre>"},{"location":"api/models/#cynetdiff.models.DiffusionModel.set_seeds","title":"<code>set_seeds(seeds, seed_probs=None)</code>","text":"<p>Sets the initial active nodes (seeds) for the diffusion process. Must be valid nodes in the graph. If activation probabilities are set, they represent the probability of activation for each seed node. Must be in the range [0.0, 1.0].</p> <p>Parameters:</p> Name Type Description Default <code>seeds</code> <code>Iterable[int]</code> <p>Seeds to set as initially active.</p> required <code>seed_probs</code> <code>Optional[Iterable[float]]</code> <p>Activation probabilities for each seed node. Entries must be in the range [0.0, 1.0]. Length must be equal to seeds. If not set, seeds are always active.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a node in the seed set is invalid (not in the graph).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.set_seeds([0, 1, 2])\n&gt;&gt;&gt; set(model.get_activated_nodes())\n{0, 1, 2}\n</code></pre>"},{"location":"api/models/#cynetdiff.models.IndependentCascadeModel","title":"<code>IndependentCascadeModel</code>","text":"<p>               Bases: <code>DiffusionModel</code></p> <p>A Diffusion Model representing the Independent Cascade process. This class is a subclass of the DiffusionModel and provides specific implementations for the Independent Cascade diffusion process.</p> <p>Parameters:</p> Name Type Description Default <code>starts</code> <code>array</code> <p>An array of start indices for each node's edges in the edge array. Type of array elements must be <code>unsigned int</code>.</p> required <code>edges</code> <code>array</code> <p>An array of edges represented as integer indices of nodes. Type of array elements must be <code>unsigned int</code>.</p> required <code>payoffs</code> <code>array</code> <p>An array of payoffs for each node if activated. Type of array elements must be <code>float</code>.</p> <code>None</code> <code>activation_prob</code> <code>float</code> <p>Uniform activation probability for the Independent Cascade model. Defaults to <code>0.1</code>. Should not be set if <code>activation_probs</code> is set. Must be in [<code>0.0</code>,<code>1.0</code>].</p> <code>0.1</code> <code>activation_probs</code> <code>array</code> <p>Set individual activation probabilities for the Independent Cascade model. Overrides <code>activation_prob</code>. Array elements must be <code>float</code>s in [<code>0.0</code>,<code>1.0</code>].</p> <code>None</code> <code>rng</code> <code>Generator | BitGenerator | None</code> <p>Random number generator to use for the model. If not set, creates a new generator by default.</p> <code>None</code> <code>_edge_probabilities</code> <code>array</code> <p>An array of success probabilities for each edge, default is None.</p> <code>None</code>"},{"location":"api/models/#cynetdiff.models.IndependentCascadeModel.compute_marginal_gains","title":"<code>compute_marginal_gains(seed_set, new_seeds, num_trials)</code>","text":"<p>Computes the marginal gain of adding each seed in new_seeds on top of the original seed_set. Averages over num_trials number of randomized activations. Scores are computed using payoffs if set, otherwise the number of activated nodes is used.</p> <p>Parameters:</p> Name Type Description Default <code>seed_set</code> <code>Iterable[int]</code> <p>An iterable representing the current seed set. Can be empty.</p> required <code>new_seeds</code> <code>List[int]</code> <p>New seeds to compute marginal gains on. Can be empty.</p> required <code>num_trials</code> <code>int</code> <p>Number of randomized trials to run.</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>List containing computed marginal gains. First entry is average influence of the starting seed set. Following entries are marginal gains with the addition of vertices from new_seeds in order. Has length len(new_seeds)+1.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.compute_marginal_gains([0, 1, 2], [3, 4], 100)\n[3.0, 1.0, 1.0]\n</code></pre>"},{"location":"api/models/#cynetdiff.models.LinearThresholdModel","title":"<code>LinearThresholdModel</code>","text":"<p>               Bases: <code>DiffusionModel</code></p> <p>A Diffusion Model representing the Linear Threshold process. This class is a subclass of the DiffusionModel and provides specific implementations for the Linear Threshold diffusion process.</p> <p>Parameters:</p> Name Type Description Default <code>starts</code> <code>array</code> <p>An array of start indices for each node's edges in the edge array. Type of array elements must be <code>unsigned int</code>.</p> required <code>edges</code> <code>array</code> <p>An array of edges represented as integer indices of nodes. Type of array elements must be <code>unsigned int</code>.</p> required <code>payoffs</code> <code>array</code> <p>An array of payoffs for each node if activated. Type of array elements must be <code>float</code>.</p> <code>None</code> <code>influence</code> <code>array</code> <p>An array of influence values for each edge. Array elements must be <code>float</code>s in [<code>0.0</code>,<code>1.0</code>]. If not set, the inverse of the in-degree of a node is used for the influence.</p> <code>None</code> <code>rng</code> <code>Generator | BitGenerator | None</code> <p>Random number generator to use for the model. If not set, creates a new generator by default.</p> <code>None</code>"},{"location":"api/models/#cynetdiff.models.LinearThresholdModel.compute_marginal_gains","title":"<code>compute_marginal_gains(seed_set, new_seeds, num_trials, *, _node_thresholds=None)</code>","text":"<p>Computes the marginal gain of adding each seed in new_seeds on top of the original seed_set. Averages over num_trials number of randomized activations. Scores are computed using payoffs if set, otherwise the number of activated nodes is used.</p> <p>Parameters:</p> Name Type Description Default <code>seed_set</code> <code>Iterable[int]</code> <p>An iterable representing the current seed set. Can be empty.</p> required <code>new_seeds</code> <code>List[int]</code> <p>New seeds to compute marginal gains on. Can be empty.</p> required <code>num_trials</code> <code>int</code> <p>Number of randomized trials to run.</p> required <p>Returns:</p> Type Description <code>List[float]</code> <p>List containing computed marginal gains. First entry is average influence of the starting seed set. Following entries are marginal gains with the addition of vertices from new_seeds in order. Has length len(new_seeds)+1.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model.compute_marginal_gains([0, 1, 2], [3, 4], 100)\n[3.0, 1.0, 1.0]\n</code></pre>"},{"location":"api/utils/","title":"Utilities","text":""},{"location":"api/utils/#cynetdiff.utils","title":"<code>cynetdiff.utils</code>","text":"<p>Functions used to convert NetworkX graphs to usable models.</p>"},{"location":"api/utils/#cynetdiff.utils.check_csr_arrays","title":"<code>check_csr_arrays(starts, edges)</code>","text":"<p>Asserts that the graph represented by <code>starts</code> and <code>edges</code> is in valid compressed sparse row (CSR) format. Useful for debugging, before the manual construction of a model.</p> <p>Parameters:</p> Name Type Description Default <code>starts</code> <code>array</code> <p>An array of start indices for each node's edges in the edge array. Type of array elements must be <code>unsigned int</code>.</p> required <code>edges</code> <code>array</code> <p>An array of edges represented as integer indices of nodes. Type of array elements must be <code>unsigned int</code>.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input parameters are not in valid CSR format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import array\n&gt;&gt;&gt; starts = array.array(\"I\", [0, 2, 4, 5])\n&gt;&gt;&gt; edges = array.array(\"I\", [1, 2, 0, 3, 7])\n&gt;&gt;&gt; check_csr_arrays(starts, edges)\nValueError: Value in edges \"7\" must be in the range [0,3].\n</code></pre>"},{"location":"api/utils/#cynetdiff.utils.edgelist_to_csr_arrays","title":"<code>edgelist_to_csr_arrays(edgelist)</code>","text":"<p>Converts an edge list to compressed sparse row (CSR) arrays. The edge list should be a sequence of tuples, where each tuple represents an edge in the graph. Each tuple should contain two integers representing the nodes of the edge. The function returns the CSR arrays, as well as a dictionary mapping the original node names to the new node names.</p> <p>Parameters:</p> Name Type Description Default <code>edgelist</code> <code>Iterable[Tuple[int, int]]</code> <p>An iterable of tuples, where each tuple contains two integers representing the nodes of an edge in the graph.</p> required <p>Returns:</p> Type Description <code>Tuple[array, array, Dict[int, int]]</code> <p>A tuple containing the starts array, edges array, and a dictionary mapping the original node names to the new node names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; starts, edges, rename_dict = edgelist_to_csr_arrays([(0, 1), (1, 2), (2, 0)])\n&gt;&gt;&gt; check_csr_arrays(starts, edges)\n</code></pre>"},{"location":"api/utils/#cynetdiff.utils.networkx_to_ic_model","title":"<code>networkx_to_ic_model(graph, *, activation_prob=None, rng=None, _include_succcess_prob=False)</code>","text":"<p>Converts a NetworkX graph into an Independent Cascade model. Includes activation probability values if they are defined on each edge under the key <code>\"activation_prob\"</code>. Activation probability should only be set on either edges or through the function argument, not both.</p> <p>Payoffs for each node are included if they are defined on each node under the key <code>\"payoff\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or DiGraph</code> <p>A NetworkX graph or directed graph.</p> required <code>activation_prob</code> <code>float</code> <p>Activation probability for the Independent Cascade model, by default <code>None</code>. If not set, and <code>\"activation_prob\"</code> key not found on edges, set to 0.1.</p> <code>None</code> <code>rng</code> <code>Generator | BitGenerator | None</code> <p>Random number generator to use for the model. If not set, creates a new generator by default.</p> <code>None</code> <code>_include_succcess_prob</code> <code>bool</code> <p>If True, includes success probabilities for each edge. These probabilities are then stored in the edge data dictionary with the key \"success_prob\", by default False. Used mainly for testing.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[IndependentCascadeModel, dict[Any, int]]</code> <p>A tuple with the instance of IndependentCascadeModel using the given graph and a dictionary mapping the nodes of the graph to their integer labels in the model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; graph = nx.erdos_renyi_graph(10, 0.5)\n&gt;&gt;&gt; model, _ = networkx_to_ic_model(graph)\n</code></pre>"},{"location":"api/utils/#cynetdiff.utils.networkx_to_lt_model","title":"<code>networkx_to_lt_model(graph, rng=None)</code>","text":"<p>Converts a NetworkX graph into a Linear Threshold model. Includes influence values if they are defined on each edge under the key <code>\"influence\"</code>.</p> <p>Payoffs for each node are included if they are defined on each node under the key <code>\"payoff\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or DiGraph</code> <p>A NetworkX graph or directed graph.</p> required <code>rng</code> <code>Generator | BitGenerator | None</code> <p>Random number generator to use for the model. If not set, creates a new generator by default.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[LinearThresholdModel, dict[Any, int]]</code> <p>A tuple with the instance of LinearThresholdModel using the given graph and a dictionary mapping the nodes of the graph to their integer labels in the model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; graph = nx.erdos_renyi_graph(10, 0.5)\n&gt;&gt;&gt; model, _ = networkx_to_lt_model(graph)\n</code></pre>"},{"location":"api/utils/#cynetdiff.utils.set_activation_random_sample","title":"<code>set_activation_random_sample(graph, weight_set, *, rng=None)</code>","text":"<p>Set activation probability on each edge uniformly at random from the given weight set. Should be used on graphs before creating the independent cascade model.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or DiGraph</code> <p>A NetworkX graph or directed graph.</p> required <code>weight_set</code> <code>AbstractSet[float]</code> <p>The set of weights to sample from. Assigns each edge in the input graph a weight uniformly at random from this set.</p> required <code>rng</code> <code>Generator | BitGenerator | None</code> <p>Random number generator to use for the model. If not set, creates a new generator by default.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; graph = nx.complete_graph(5)\n&gt;&gt;&gt; set_activation_random_sample(graph, range_start=0.1, range_end=0.2)\n&gt;&gt;&gt; model, _ = networkx_to_ic_model(graph)\n</code></pre>"},{"location":"api/utils/#cynetdiff.utils.set_activation_uniformly_random","title":"<code>set_activation_uniformly_random(graph, *, range_start=0.0, range_end=1.0, rng=None)</code>","text":"<p>Set activation probability on each edge uniformly at random in the range [<code>range_start</code>, <code>range_end</code>). Must have that <code>0.0</code> &lt;= <code>range_start</code> &lt; <code>range_end</code> &lt;= <code>1.0</code>. Should be used on graphs before creating the independent cascade model.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or DiGraph</code> <p>A NetworkX graph or directed graph.</p> required <code>range_start</code> <code>float</code> <p>The start of the range to sample activation probabilities from. If not set, defaults to <code>0.0</code>.</p> <code>0.0</code> <code>range_end</code> <code>float</code> <p>The end of the range to sample activation probabilities from. If not set, defaults to <code>1.0</code>.</p> <code>1.0</code> <code>rng</code> <code>Generator | BitGenerator | None</code> <p>Random number generator to use for the model. If not set, creates a new generator by default.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; graph = nx.complete_graph(5)\n&gt;&gt;&gt; set_activation_uniformly_random(graph, range_start=0.1, range_end=0.2)\n&gt;&gt;&gt; model, _ = networkx_to_ic_model(graph)\n</code></pre>"},{"location":"api/utils/#cynetdiff.utils.set_activation_weighted_cascade","title":"<code>set_activation_weighted_cascade(graph)</code>","text":"<p>Set activation probability on each edge (u,v) to 1/in_degree(v). Graph must be directed. Should be used on graphs before creating the independent cascade model.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>A NetworkX directed graph.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; graph = nx.complete_graph(5)\n&gt;&gt;&gt; set_activation_weighted_cascade(graph, range_start=0.1, range_end=0.2)\n&gt;&gt;&gt; model, _ = networkx_to_ic_model(graph)\n</code></pre>"},{"location":"examples/activated/","title":"Observing Activated Nodes","text":""},{"location":"examples/activated/#motivation-and-starter-code","title":"Motivation and Starter Code","text":"<p>Instead of just the number of activated nodes, suppose that we want to get the nodes themselves. We start with similar code as the basic example from the README:</p> <pre><code>import random\nimport networkx as nx\nfrom cynetdiff.utils import networkx_to_ic_model\n\n# Randomly generate the graph\nn = 1_000\np = 0.05\nk = 10\ngraph = nx.watts_strogatz_graph(n, k, p)\n\n# Randomly choose seed nodes\nk = 10\nnodes = list(graph.nodes)\nseeds = random.sample(nodes, k)\n\n# Set the activation probability uniformly and set seeds\nmodel, _ = networkx_to_ic_model(graph, activation_prob=0.2)\nmodel.set_seeds(seeds)\n</code></pre>"},{"location":"examples/activated/#obtaining-the-activated-nodes","title":"Obtaining the activated nodes","text":"<p>Next, we run the model until completion and can view the nodes that were activated:</p> <pre><code>model.advance_until_completion()\nactivated_nodes = set(model.get_activated_nodes())\n</code></pre>"},{"location":"examples/activated/#counting-the-number-of-activations","title":"Counting the number of activations","text":"<p>This functionality is useful in cases where we are interested in how often particular nodes are activated.</p> <p>Over <code>n_sim = 1_000</code>, we can record the number of simulations where a node is activated:</p> <pre><code>n_sim = 1_000\ntimes_seen = dict()\n\nfor _ in range(n_sim):\n    model.reset_model()\n    model.advance_until_completion()\n\n    for activated_node in model.get_activated_nodes():\n        if activated_node not in times_seen:\n            times_seen[activated_node] = 0\n\n        # Increment seen counter for each node\n        times_seen[activated_node] += 1\n</code></pre>"},{"location":"examples/activated/#getting-the-most-frequently-activated-nodes","title":"Getting the most frequently activated nodes","text":"<p>The <code>times_seen</code> dictionary now contains the number of simulations each node has been activated in. To get the top <code>l = 50</code> activated nodes, we can run the following:</p> <pre><code>nodes_sorted_by_activation_frequency = sorted(\n    times_seen.items(), key=lambda pair: -pair[1]\n)\nl = 50\nprint(nodes_sorted_by_activation_frequency[:l])\n</code></pre>"},{"location":"examples/celf/","title":"Influence Maximization","text":""},{"location":"examples/celf/#motivation-and-problem-definition","title":"Motivation and Problem Definition","text":"<p>Suppose we are interested in computing the seed set which activates the most number of nodes in expectation. This problem is known as influence maximization. Given a graph \\(G = (V,E)\\) and a fixed budget \\(k\\), we wish to choose a seed set \\(S \\subseteq V\\) such that \\(|S| = k\\) and the influence \\(\\sigma(S)\\) on the graph is maximized.</p>"},{"location":"examples/celf/#overview-of-celf","title":"Overview of CELF","text":"<p>A well-known algorithm for this problem is the CELF algorithm, which is an optimized version of the greedy algorithm. At a high level, this algorithm works by greedily adding nodes to the seed set which has the highest marginal gain. This is repeated until the budget is exhausted.</p> <pre><code>import typing as t\nfrom cynetdiff.models import DiffusionModel\nfrom tqdm import tqdm, trange\nimport heapq\n\n\ndef celf(\n    model: DiffusionModel, n: int, k: int, num_trials: int = 1_000\n) -&gt; t.Tuple[t.Set[int], t.List[float]]:\n    \"\"\"\n    Input: graph object, number of seed nodes\n    Output: optimal seed set, resulting spread, time for each iteration\n    Code adapted from this blog post:\n    https://hautahi.com/im_greedycelf\n    \"\"\"\n\n    # Run the CELF algorithm\n    marg_gain = []\n\n    print(\"Computing marginal gains.\")\n    # First, compute all marginal gains\n    for node in trange(n):\n        marg_gain.append(\n            (\n                -model.compute_marginal_gains([node], [], num_trials),\n                node,\n            )\n        )\n\n    # Convert to heap\n    heapq.heapify(marg_gain)\n\n    max_mg, selected_node = heapq.heappop(marg_gain)\n    seeds = [selected_node]\n    spread = -max_mg\n    spreads = [spread]\n\n    print(\"Greedily selecting nodes.\")\n    # Greedily select remaining nodes\n    for _ in trange(k - 1):\n        while True:\n            current_mg, current_node = heapq.heappop(marg_gain)\n            new_mg_neg = -model.compute_marginal_gains(seeds, [current_node], num_trials)[1]\n\n            if new_mg_neg &lt;= current_mg:\n                break\n            else:\n                heapq.heappush(marg_gain, (new_mg_neg, current_node))\n\n        spread += -new_mg_neg\n        seeds.append(current_node)\n        spreads.append(spread)\n\n    # Return the maximizing set S and the increasing spread values.\n    return seeds, spreads\n</code></pre>"},{"location":"examples/celf/#running-the-algorithm","title":"Running the Algorithm","text":"<p>To see this in action, we can create a model as before and run our algorithm. We'll be using the trivalency weighting scheme to set our activation probabilities:</p> <pre><code>import networkx as nx\nfrom cynetdiff.utils import networkx_to_ic_model, set_activation_random_sample\n\nn = 5_000\n# Randomly generate the graph\nic_graph = nx.random_regular_graph(7, n).to_directed()\n# Set activation probabilites\nset_activation_random_sample(ic_graph, {0.1, 0.01, 0.001})\n# Create corresponding model\ncelf_ic_model, _ = networkx_to_ic_model(ic_graph)\n\nnum_seeds = 20\n# Get best seed set returned by the algorithm\ncelf_ic_seeds, ic_marg_gains = celf(celf_ic_model, n, num_seeds)\n</code></pre>"},{"location":"examples/celf/#trying-different-models","title":"Trying Different Models","text":"<p>The <code>celf</code> function also works with the Linear Threshold diffusion model:</p> <pre><code>from cynetdiff.utils import networkx_to_lt_model\n\nn = 5_00\n# Randomly generate the graph\nlt_graph = nx.random_regular_graph(7, n).to_directed()\n\n# Set weighting scheme\ncelf_lt_model, _ = networkx_to_lt_model(lt_graph)\n\nnum_seeds = 20\n# Get best seed set returned by the algorithm\ncelf_lt_seeds, lt_marg_gains = celf(celf_lt_model, n, num_seeds)\n</code></pre>"},{"location":"examples/preliminaries/","title":"Network Diffusion Preliminaries","text":"<p>Network diffusion models aim to capture the spread of trends through networks. At discrete time steps, new nodes are activated according to the parameters of the model. Here, we will introduce the Independent Cascade (IC) and Linear Threshold (LT) models, along with the corresponding primitives provided by <code>CyNetDiff</code>.</p>"},{"location":"examples/preliminaries/#model-context","title":"Model Context","text":"<p>We first discuss traits common to all network diffusion models. Given a (possibly directed) graph \\(G=(V,E)\\), the process starts with a set \\(S \\subseteq V\\), called the seed set, being the initially active nodes. The model proceeds in discrete time steps, where nodes are activated according to rules set by the different models. The process runs until no further activation is possible.</p> <p>In <code>CyNetDiff</code>, diffusion models are represented by a model class. In the following, suppose we have an instance of an existing diffusion <code>model</code>. To set the initially active nodes from a set <code>seed_set</code>, simply run:</p> <pre><code>model.set_seeds(seed_set)\n</code></pre> <p>To advance the diffusion process one time step, run:</p> <pre><code>model.advance_model()\n</code></pre> <p>This function has no effect if no activations are possible.</p> <p>To run the diffusion model until completion (i.e., until no more activations are possible), run:</p> <pre><code>model.advance_until_completion()\n</code></pre> <p>A generator for the newly activated nodes can be obtained by: <pre><code>model.get_newly_activated_nodes()\n</code></pre> Note that at time step zero, this yields the same elements as <code>seed_set</code>.</p> <p>A generator for all activated nodes (not just ones in the latest time step) can be obtained by: <pre><code>model.get_newly_activated_nodes()\n</code></pre></p> <p>Finally, to reset the model to it's initial state (only seed nodes are activated), run: <pre><code>model.reset_model()\n</code></pre></p> <p>All network diffusion models are stochastic, in that the nodes activated depend on random variables as well as the model parameters. Thus, resetting and re-running the diffusion process is important for obtaining useful information from these models.</p>"},{"location":"examples/preliminaries/#independent-cascade-model","title":"Independent Cascade Model","text":"<p>In the independent cascade model, when a node \\(v \\in V\\) first becomes active, it will be given a single chance to activate each currently inactive neighbor \\(u\\). The activation succeeds with probability \\(p_{v,u}\\) (independent of the history thus far). If \\(u\\) has multiple newly activated neighbors, their attempts occur in an arbitrary order. If \\(v\\) succeeds, then \\(u\\) will become active; but whether or not \\(v\\) succeeds, it cannot make any further attempts to activate \\(u\\) in subsequent rounds.</p> <p><code>CyNetDiff</code> supports simulating the above process by the use of a model class. This class stores the state of the diffusion model, and can be manually advanced by repeated function calls. To start, if we have a <code>NetworkX</code> graph <code>graph</code>, we can create a corresponding model with the following:</p> <pre><code>from cynetdiff.utils import networkx_to_ic_model\nmodel, _ = networkx_to_ic_model(graph)\n</code></pre> <p>By default, the activation probabilities are all set to a default of <code>0.1</code>. There are a number of different commonly-used weighting schemes which can be set by <code>CyNetDiff</code>.</p>"},{"location":"examples/preliminaries/#weighting-schemes","title":"Weighting Schemes","text":"<p>In the IC model, the weighting scheme is how the probabilities \\(p_{v,w}\\) are chosen. There are three common weighting schemes handled by utility functions from <code>CyNetDiff</code>:</p> <ul> <li>We can choose the weights \\(p_{v,u} \\in [0,1]\\), uniformly at random. This can be set by calling the function <code>set_activation_uniformly_random(graph)</code>.</li> <li>We can choose the weights \\(p_{v,u}\\), uniformly at random from a set <code>weight_set</code>. This can be set by calling the function <code>set_activation_random_sample(graph, weight_set)</code>.</li> <li>We can choose the weights \\(p_{v,u} = \\frac{1}{|N^{in}(u)|}\\) as the inverse of the in-degree of \\(u\\). This can be set by calling the function <code>set_activation_weighted_cascade(graph)</code>. The input graph must be directed to use this weighting scheme.</li> </ul> <p>To apply a given weighting scheme, we simply call the corresponding helper function from the utility module of <code>CyNetDiff</code>. For example, to use the well-known trivalency weighting scheme, simply call:</p> <pre><code>from cynetdiff.utils import set_activation_random_sample, networkx_to_ic_model\n# Setting weights is done in-place.\nset_activation_random_sample(small_world_graph, {0.1, 0.01, 0.001})\n# Make sure to set the weights before creating the model.\nmodel, _ = networkx_to_ic_model(small_world_graph)\n</code></pre> <p>Custom weights can be set under the <code>\"activation_prob\"</code> data key on each edge in the starting <code>NetworkX</code> graph.</p>"},{"location":"examples/preliminaries/#linear-threshold-model","title":"Linear Threshold Model","text":"<p>In the linear threshold model, each directed edge \\((v,u)\\) is given an influence \\(w_{v,u} \\in [0,1]\\) such that \\(\\sum_{v \\in N^{in}(u)} w_{v,u} \\leq 1\\), so that the total incoming influence at every node is at most one. Each node \\(u \\in V\\) is assigned an activation threshold \\(\\theta_u \\in (0,1]\\) uniformly at random. Let \\(A_t\\) denote the nodes active at time step \\(t\\). A node \\(u\\) becomes active at time step \\(t + 1\\) if $$     \\sum_{v \\in N^{in}(u) \\cap A_t} w_{v,u} \\geq \\theta_u. $$ In words, this occurs if the influence of \\(u\\)'s active in-neighbors is at least \\(\\theta_u\\).</p> <p>To create a linear threshold model from an <code>NetworkX</code> graph <code>graph</code>, simply run:</p> <pre><code>from cynetdiff.utils import networkx_to_lt_model\nmodel, _ = networkx_to_lt_model(graph)\n</code></pre> <p>By default, the graph is made directed if it is not, and influences are set to the inverse of the in-degree, i.e. \\(w_{v,u} = \\frac{1}{|N^{in}(u)|}\\). Custom influence values can be set under the <code>\"influence\"</code> data key on each edge in the starting <code>NetworkX</code> graph.</p>"}]}